一致性哈希环 和 随机树

分散节点存储热点信息协议缓解互联网压力
1
抽象定义
 
	我们描述一种分布式缓存协议，我们可以减少或者消除互联网过热节点的产生。我们的协议专门为使用非常多的网络服务的情况，
	例如互联网，因为过节点过热引起的延迟，服务器之间激烈的竞争导致网络服务不可用，这个协议非常被实施基于现在已经存在的协议例如TCP/IP协议，并且开销非常小。
	这个协议由本地控制，非常高效，并且随着互联网的扩展可以健壮的扩展。
	
	我们的存储协议是基于特殊的一种哈希方式我们称之为一致性哈希。大致的说，一个一致性哈希哈函数在一个函数范围内应当改变最小，只要开发一个好的一致性哈希函数，
	我们就有能力开发这个存储协议不需要用户有一个网络上的数据流动方向或者一个一致性的视图。
	我们相信一致性函数最终被证明是有用的在其他的应用上，例分散有名服务器集群或者配额系统。
1
序言：

   在这篇论文中，我们描述一种应用于互联网的分布式存储协议，目的在于减少或者消除“过热节点”，“过热节点"很多时候都因为大量的客户端并发的请求存取数据。如果在这个时候没有提供足够准备处理这些客户端的连接，服务器就有可能崩溃或者下线。
   我们有很多过热节点现象发生的经历在web上。一个WEB节点很可能在一个非常短的时间内变成一个很受欢迎的节点，因此必须在一个相对较短的时间内处理大量的请求，基于本来的配置。事实上，一个节点可能接收了过多的请求变成了一个被“被塞满的状态”变成典型的不可用。除了一个节点因为请求过多边的不可到达，也会影响周围的网络，周围的网络就会变的拥堵然后被影响。WEB的使用增加，所以过热节点出现更频繁，产生的冲击力更大，最近著名的过热节点的例子是一个IBM 的节点在深蓝国际象棋锦标赛，并且有几个政党选举在多种因素的作用下，用户无法成功修改或取数据达几个小时甚至一天，其它的例子包括“XXX”这个新的受欢迎的软件。
    我们的工作就是积极的解决这个问题关于互联网过热节点的问题，我们相信我们开发的工具可能关于CS模型因为中央服务器在互联网上作为一种域名服务器，连接的标签服务器也是容易受影响而变成过热节点的。
1.1
过去的工作：
 
   过去有几个解决“过热节点“的方法被提出。大多数方式都是采用拷贝很多副本的方式，保持互联网上有很多副本存在。通过这种方式可以把一个过热的节点分配成多个服务器节点。在一些协议中已经被广泛的使用，很多客户端共享一个代理缓存节点，所有的请求通过这个节点转发到相应的服务器。并且尝试保存频繁被使用的页。它尝试去使用缓存副本来满足要求，如果缓存访问失败，就会把这些请求导向主服务器。这种解决方式的一个缺陷是，当越多客户端共享这个节点的时候，效果越好，但是缓存本身将逐渐负载变大。
   Malpani等人的工作围绕这个问题展开，他们做了一个高速缓存组功能。一个用户的请求被定向到任意一个缓存，如果需要的这个页面在这个缓存中，就返回给用户，否则这个缓存将通过多播的方式请求别的缓存节点，如果其它的节点也没有缓存相应数据，就通过访问主节点或取信息。这个技术的缺点是如果缓存节点非常多，甚至使用了组播的方式，庞大的消息会变的不可控制（甚至影响网络）。我们这个论文阐述的工具一致性哈希给我们提供了一种方法，作为一种分布式缓存，但是不需要节点之间频繁的交流数据。我们将在第四节谈论这个问题。
   Chankhunthod 等人开发的“收获式缓存”使用树形结构组织了一种可伸缩的缓存体系。一个用户请求一个页通过请求最近的叶子节点，如果这个节点没有缓存它的兄弟节点也没有缓存，这个请求将会被传递给它的父亲节点。如果在树中没有这个节点，这个请求最终会到根结点然后被转发。这个节点以后将保留一个这个页面的拷贝，这种树型结构的好初是它接收到的请求只可能来自孩子节点和兄弟节点，确保不会同时有太多的请求，否则再一个很短的时间内请求一个主页面会导致主节点只能处理相应的较少的请求，导致过载。这个方法表也有以个缺点，这样的树必须缓存所有的页面，当根节点接收到至少一个请求时，已经遍历了整个树。当访问不同节点的请求在一个很短的时间内快速增长的时候，根节点就会陷入一种非常繁忙的状态，意味着我们的节点存在着潜在的风险。
   Plaxton and Rajaraman 展示了如何使用哈希和随机来负载均衡每一个缓存节点，特别的他们使用了一种包含虚拟节点的层次结构，通过使用随机哈希函数将互联网上的虚拟节点和切实存在的节点相对应起来。客户端发送一个请求向这个层级的集合的一个随机节点，缓存节点拷贝一些页到下一个节点，当他们发现这个集合很大的时候，就进行一次快速的回应，即使是最热的页，因为最大的那个节点还没有过载。这样也许提供了一种负载均衡的办法，一个机器在一个小节点，一个页在一个大节点。
   这个算法还是年优缺点的，如果发送一个请求，请求拷贝所有的节点，一个小的集合肯定会负载过大。事实上这种算法在他们的并联系统上工作的更好，独立的节点很难标依赖快速恢复来完成工作，并且在互连网上还可能出现问题。这个算法要求节点之间的通信是同步的并消息有序，每个用户都该看到全局缓存。

1.2  
我们的贡献：
    
    这里我们描述两个工具对于数据复制，使用这种算法来克服前两种算法的缺点并且提升性能。
    我们的第一个工具，随机存储树。我们根据前人的结构，使用一个树来合并缓存请求，并使用一棵完全不同的树通过哈希函数来缓存其它页面，作为负载均衡。
    通过联系上面说过的算法，结合我们自己的方法，我们后边将讨论如何减少内存的使用，并且缓存使用最多的页面。
    
    我们相信一棵内存树的而外的开销在实践中的应用是非常小的。请求一个页面的时间和树的深度挂钩。然而一个页面的请求花费的时间时非常少的，但是额外的消耗也是应当尽量减少的。
    
    页的返回可以看作是流水线化的，一个缓存不需要等待到它接收到一个完整的页面之前才发送数据到孩子在的树上。因此一个页面的反馈仅仅需要一些时间。
    总之用户看到的延迟是较小的。
    
    我们的第二个工具是一种很新的哈希方式，我们叫它一致性哈希方式，这种哈希方式 来自于Plaxton/Rajaraman和其它的使用系统。
    
    典型的哈希方法因为在固定节点数的集群上表现出优秀的负载均衡能力而被人们知道。然而互联网上并没有固定节点的集群。
    然而，这些服务器在网络上来了有去，当他们崩溃时下线，正常时重新上线。更糟糕的时网络传播信息并不稳定。
    以至于客户端可能需要面对不同的数据视图，因为服务器可能在数据传输过程中修改了数据。这会使得标准哈希失效，因为它依赖于客户端指定的特定页面。
    举例来说，Feeley 等人实施了一种分布式共享内存系统在互联网上，我们为每个工作站提供一个哈希表，描述分布式结构解决问题。
    每次有新的节点进入互联网，需要中心控制节点修改哈希表并且通知所有节点。
   一致性哈希可能会解决这些问题，和大多数哈希方式一样，一致性哈希支持将项目分配到桶中，这样每个桶的数目大致相同。
   
   不像标准的哈希方式，一致性哈希修改了桶的大小不会影响全局的范围和桶的映射，此外，将散列对象分成不同的桶，只对桶的项目有轻微的不同分配。
   
   我们将一致性哈希使用在我们的缓存树当中，并且展示这种方法如何有效，甚至可以让每一个客户端在常数时间内达到想要的服务器，Lit等人提出了这个哈希函数允许在顺序上添加一个桶，
   然而我们的哈希函数允许多次添加桶任意次，DEVIN 提供了一个改进的方案，此外，我们相信一致性哈希，将会非常有用在很多的方面，例如，定额系统或者分布式服务器，或者需要更多的机器，或者很多的机器在不同的视角共享一个有名的服务器集群并且不需要太多的交流。

1.3总览

在第二节我们描述了我们的方法，并且说了WEB的过热节点问题，我们相信这个哈希函数足够丰富以至于我们可以在发展中变的更好，并且在实际环境中有巨大作用。我们在第3节将会描述我们的随机数树方法，并且使用它有效的消除过热节点，使用一个简单的方法，独立于第3节的是，在第4节我们将会展现使用一致性哈希算法解决过热节点的问题，使用一个视角上不同于我们以有的简单方法的方法。在第5小节我们需要结合这两种有效的技术。在第6节，我们提出一种简单的延时方法，捕获互联网上的集群。我们将展示把我们的协议会实际延伸到真实的有延时模型，在第7.8节我们考虑容错和超时行为，在第9节我们将分别讨论扩展和开放性问题。

1.4一些标注关于随机和哈希

一般情况下，我们使用哈希函数将图中的一个类散列成一个范围。为了清晰起见我们假设这些东西被一个真正的随机函数散列。均匀并且独立的，在现实情况中有限制的哈希函数被使用的更多，因为它更节省空间和具有相对的我们的随机性。我们在这里需要证明所有的情况使用有限制的哈希函数。然而在这种扩展的抽象中我们需要独立的请求结果。有限独立性的证明将会出现在整个论文中。


2.模型

在这一节将展示用于WEB销减过热节点问题的模型。
我们很清楚计算机在WEB 上可以分为三个类别，所有的请求页都是由浏览器发起的，而网页的持久化在服务器上，缓存是额外的服务器用来接收浏览器的请求，然后减缓服务器的压力，在这篇论文中缓存的集合以及很多的缓存都定义为C。
 每一个页都有存在一个服务器上，缓存有能力存储很多的页面，缓存在中的内容会根据时间和协议变化。我们假设每一页的内容是不会改变的。在第9节我们将会详细的讨论这种情况，所有页的集合我们定义为P。任何机器都可能发送一条有限制的消息，服务器可能并不能发现存在的所有缓存。我们只需要每个服务器知道高速缓存的1/T就可以。对典型的页面我们有两种要求。一个服务器由于接收太多的请求以至于自己的很快的不能提供其它的服务，我们称它为“被拥塞的”。延迟意味着一条消息从M1机器到M2机器的时间。我们表示这个数量为～@2～.(参考附录公式）在实际的应用中，当然延迟并不是一个可以这样刻画的简单特征。我们将这个服务器的时间优化成了一个比较理想的环境。当然我们的协议正确性不能依赖于这个假象的延时值。我们还需要考虑稳定性，吞吐量，效率等一系列指标。
 请注意，我们不是要做一个计算延迟大小的函数，这个问题将在3.2.1节讨论。

所有的缓存，服务器行为以及浏览器行为在我们的协议中都是已经指定的。特别的这个协议指定了服务器和缓存之间的应答请求，并且指定每一个缓存页存储在缓存中的位置。所有的控制必须在本地，机器的行为必须依赖于它接收的消息。
 由对手来决定浏览器的请求页，然而它并不能看到我们策略中的随机数，然而不能适应它的请求，再一个可以观测到的延迟上。我们考虑2种模型，首先，我们考虑一个静态的模型，一个单一的批处理请求，请求R=pc的所有的请求页面，我们也考虑一个动态模型，对手可能引发新的请求新的页面，设时间间隔为r,则总共请求所有页面的r倍。

目的：
   解决这个过热节点的问题，是要满足所有浏览器请求页面的要求，并且确保有很高的概率没有缓存或者服务器是“被拥塞的”，很高的概率在这里是指可能性至少有1 - 1/N ，N 是一个确定的被全局使用的参数。我们的请求是基于保护服务器，但是我们也有两个额外的请求，这个协议应当能很好的工作，并且不需要太多节点来缓存大量的页面。第二个目标是，一般情况下，请求一个页面需要最小的延时。

3.随机树

   在这一节我们介绍第一个工具，随机树。首先来说一个简单的例子，我们得到一个简单的缓存协议，它可以工作的很好，专门的我们来做一个简单的模型：
   1.所有的机器都可以感知到所有的缓存
   2.延迟f(m1,m2) = 1 for all (i != j)
   3.所有的请求都在同一个时间内发生
   这些限制都是静态的场景，在这个场景中仅仅只有一次批处理请求，我们不需要一个长期的稳定性在这个网络中。在这种限制下，我们需要展示一种行为比较好的行为。这里有很高的概率没有机器是被拥塞的，我们总体实现了一个延时在LOG（C）并且证明了是最优的。在接下来的小节中，我们将解释如何扩展协议使之不需要一个简单假设。
   这个思想是来自于我们导论中之前讨论的，可扩展的缓存树。我们使用这种树去确定没有缓存有很多的孩子请求特别的页。如引言中讨论的，我们使用所有的存储空间将请求均匀的分成范围。水平距离根越近的地方，接收到页的请求就越多，即使这些页并不是很“热”。所以很多的页面将可能导致根结点被“拥塞”我们的技术类似于Plaxton/Rajaraman的方法类似，使用一个随机生成树缓存所有的节点，这样确保根结点附近的机器没有太多的页面请求，提供了良好的负载均衡，我们不能使用他们的方法缓存。我们的关注点在于防止被拥塞，但是他们是允许被拥塞的。
   在3.1节我们要精准定义我们的协议，在3.2节中，我们分析协议，基于高速缓存的上界，这种策略使用了每一个缓存，浏览器得到这个页面前得到这个页。
3.1 协议
   我们把这个多元树，称之为一个抽象的树，填充每个叶子节点为缓存。每棵树的节点等与缓存数。这棵树会逐渐的平衡。我们按照广度优先的规则搜索节点，这个协议被运行在这些抽象树上。基于此，
请求者对于页的所有请求采取四元组的方式进行。所需节点的名字我们需要使用节点的缓存序列来查找。缓存上的节点实际上被映射到了机器上。一棵树的根总是被映射到页面的服务器上。所有的节点被一个哈希函数散列，h : P *[1,,,,C]->C 将他们分散在浏览器和缓存上。为了不因为少数的请求产生缓存副本。我们还有一个限制参数q,在请求页面没有达到这个数字之前，我们不创建数据的副本。
现在，给定一个哈希函数，q , p,我们的协议描述如下：

浏览器：

   当浏览器需要一个页面时，它找到一个随机的叶子节点到根的路径。将节点映射到机器上为h,然后请求叶子节点的页面，请求包括浏览器的名字，请求的页面的名字，这个路径和映射的结果。

缓存：
   
   当一个缓存接收到一个请求时，它会检查是否或取一个副本或者正在或取一个缓存。如果是这样，它返回给这个页面请求者，如果必要返回副本。否则增加一个技术器，并且询问下一个页的路径。如果计数器增加到了q,将会缓存一个页面。在任何情况下，请求者都是通过缓存节点来获得页面。

服务器：
  
   当一个服务器接收到一个请求的时候，返回一个页的副本。

3.2.1 延迟

	在我们的协议之下，浏览器的延时是根据树的高度决定的。如果请求的页面被转发到根，则会是两倍的路程，时间复杂度2logdC ,
	如果这个请求直接被树上缓存的节点满足，则延迟几乎很少。
	
	
	如果请求在中途等待，等待一个节点的复制工作完成，已然不会有太大的延时，毕竟整个过程还是在树上。
	
	值的注意的是，d 这个变量在使用环境中非常大，所以延时还是比较小的。
	
	需要注意的是，我们请求一个大页面的时间在并不是根据路径遍历的增多成倍增涨的。
	原因是，该网页可以按照一个流水线的方式传播。在路径中间的缓存，可以在接收到一些数据后就
	向下一个路径节点发送。不需要等待整个页面的到来。
	
	这意味着通过这些协议将会增加获得小页面的延时，大页面的开销是可以忽略不记的。这种存在树
	的策略在实践中表明是可以接收的，我们协议可以说是约束完整的，就是为了拒绝被拥塞的情况。
	
	在这种情况下，考虑缓存节点C返回一个页面，这个图的节点相当于机器，通过这个连接图我们可以
	看到页面有没有被发送，小的延时必然意味着小的图，暗示这些节点必须有很大的度，暗示着拥塞的情况出现。

3.2.2  拥塞
        ps:分球入箱问题
	我们分析后得出以下结论。首先我们分析虚拟树上的节点的各种页面。分析的结果将会被赋予权重到节点上，我们分析树的节点，使用哈希函数将他们映射到一个真实缓存节点上面。一个服务器被请求次数越多，他的权重越大。首先结合一个预计的权重，我们基于此考虑一种情况，每个节点被赋予一个随机的机器。这是一个带有权重的“球箱问题”的分析。我们的分析得出了一个指数级结果，因此我们提出了球分配到箱子中的方法，有k = O(log N) 种独立的方法。我们可以通过使用一个通用的哈希函数散列这些虚拟的节点到机器上，我们将分析我们的协议使用一个静态模型根据这个静态模型假设内存是足够的，有足够的空间，没有页面被退出的情形。这意味着，如果一个缓存已经处理了q个对一个页面的请求，将不会对同一个界面有其它的请求。（已经缓存到了本地）在3.1中我们证明了高概率的下界的缓存数。假设这个函数的所有输出都是随机的独立的。在3.4节我们分析了高概率情况下，当h 是 K 的独立功能。特别的，我们展示出，当k的对数作为一个足够的参数时，就会有很高的概率有极大独立性。
Analysis for Random h （数学公式证明部分，暂时不考虑）

4.一致性哈希

  在这一节我们定义一种新的哈希技术，我们叫他一致性哈希。我们提出使一种方案在互联网上使用简单的方式例来复制数据。考虑一种简单的情况，加入一个服务器有很多的对象，客户端需要请求这些对象。这就很自然的产生了一层缓存结构，在客户端和服务器之间，提供负载均衡的功能。在这种情况下，对象应当被分分布式的分配在一个大致相同的缓存桶中，此外，客户端需要知道查询特定对象的缓存。这种显而易见的方法就是使用哈希方式。服务器可以使用一个哈希函数，均匀的将对象节点散列到缓存中。客户可以使用哈希函数来发现它的缓存中存储的一个对象。我们现在考虑到缓存的节点主动被改变，或者当每一个用户表请求一组不同的缓存。这种情况很可能出现在互联网上，如果一个分布式使用了一个经典的哈希函数。例如使用了一个线性同余函数(x -> ax + b(modp),不一致的后果将是灾难性的。当哈希函数变化时，它的所有对象都会被添加到一个新的位置中去。最终，所有的数据都是没有用的，因为客户端来自不同的位置。
  一致性哈希，解决了不同视角的问题，我们将所有的缓存节点组成的集合都定义成了一个统一的视角，客户端可以一致的意识到如此。我们假设视图时可以不一致的，这种情况时客观存在的，每一个机器可以意识到当前操作的缓存是一个一致的恒定的。一个客户端使用一致性哈希函数，将这个对象散列在这个视图中的一个缓存上。我们分析并且构建存在以下不同特性的哈希函数。首先必须有一个平稳的特性，当一个机器在增加或者删除一个节点，节点中的对象必须被移动在一个最小的消耗中，移动到一个缓存中。一次来保持数据完整性和负载均衡。第二，在所有的客户端的视图看来，不同缓存的总数应当时很小的。我们叫这种属性“传播”，相似的，在所有的客户端视图，每个缓存分配的不同对象的个数我们称之为“负载”。
  因此一致性的哈希解决了以上的问题，扩展属性意味着，存在不一致的视图，对于一个指定的对象将会被缓存在少量的节点，分配一个对象到一个小的缓存集合，可以保证所有的客户端都能看见这个对象，并且不需要使用太多的存储空间，负载属性意味着没有那个缓存节点负载了不合理的数目。稳定的意思暗示着在一个集合中平稳的改变一个缓存对象，这个对象位置的演化也是平滑的。
  我们有很多种方法去展示一致性。我们不会使用一个精确的定义。在4.4节中我们会定义一个扩展哈希函数，和其它几个精确的定义，以及不同的几个方面关于一致性问题。在4.2节我们会定义一致性哈希，在一定的程度上表示这四个方面，在4.4节我们将讨论一致性哈希的东西，和这篇文关系很大，展示一些丰富的东西，即使现在还没有论文展示出来，但是潜在的有价值的东西。
4.1 定义

    在这个小节我们定义关于一致性的四种概念。几个概念：
    I：对象集合 B :集合的桶。视图时任何桶的子集。
    一个哈希函数是如此来的，2^B * I -> B.这样的函数需要将尽可能的对象分配给桶，所以使用f(V,i)表示对象i被放进了视图V 中，
    限制哈希函数是限制哈希函数的一种，在本节剩余的部分我们讨论限制哈希函数的状态和关系关于限制哈希函数族。
    在整个环境下，我们使用下面的符号约定：F：限制哈希函数的族，f:一个限制哈希函数。V 是一个视图，i 是一个对象，b 是一个桶。
    
    平衡性：
        如果给定一组特定的视图，和一个随机的函数，这个哈希函数是平衡的，这个函数可以以很高
        的概论将对象平衡映射到每一个桶中，在O(1/|V|），这是个哈希函数的平衡性，
        对于标准的哈希函数是一个珍贵的属性。他们在项目执行键保持平衡。
   

    单调性：

        哈希函数是单调的。一个哈希函数族是单调的则属于这个函数族的函数都是单调的。
        这个属性描述的是，当一个新的桶加入之后，它其中的对象必须要能够移动到新的桶中，这反映出了一致性，
当一组可用桶发生变化时，如果有必要的话，物品就应该移动，以保持均匀分布。

    散列性：
        
         假设V1，，，Vn是一个视图的集合，每个视图中单独包含C个对象，则最少有C/t 个桶。一个哈希函数需要将所有对象尽4最大可能散列。
         如果一个哈希函数的散列是T则它所属的整个哈希函数族的散列能力也是T。
        散列背后的思想是，对于每一个人看到的至少是一个恒定的桶。
        每一个人都试图使用一致性哈希函数分配一个对象。这种属性通过整个族说明了，大多数不同的观点在于哪一个桶应当包含对象。
        
综上所述，一个好的哈希函数应当有一个比较高的散列性关于所有的对象。

   负载性：
          在说这个属性之前我们先定义一个集合V。对于一个哈希函数b个桶，其负载应当满足这个公式：公式参考原文@3. 一个哈希函数的最大负载是一个桶的最大负载。一个哈希函数族的负载为O则有很大的可能性这个函数族中的函数也可能是O。负载的特性类似于散列性。现在我们回到一样的多个用户的条件上来，但是这次我们考虑一个特殊的桶b,其中包括一些对象，这些属性展示了，最多明确不同的对象，至少有人认为属于一个桶。一个哈希函数应当在任何时候都具有很低的负载性。我们主要的一致性哈希结果在4.1节中展示，它展示了一个有效的单调哈希函数族，并且具有逻辑上的散列于平衡。

4.2 构造

       我们现在构造一个有很高性能的一致性哈希。假设我们现在有两个随机函数A和B ，函数A映射一个随机的区间，函数B做一样的事情，
       换句话来说，一个对象会被映射到距离它最近的一个桶，因为这将变的很明显，实际上我们需要每个桶之间距离一个以上的单位距离。
       假设在这个范围内桶的个数总是小于C，我们将会需要每个节点之间间距log(C)个单位距离，保持一个恒定的距离。
    一种简单的方法对于一个视图来说是这样的，每一个桶中的数据使用log(c)次就复制它。

在这个函数族中的一个属性就是向为了节省空间，使用随机位。我们仅仅要求函数B 和 函数使用一种复

杂度为log(c)的方法，独立的一致的在[0,1]上。

    值的注意的是，对于每一个点我们选择单位间隔，
    我们必须选择足够的随机位来区分所有的位。因此我们不太需要超过log(C)个位点，上面描述的哈希族函数也是如此。

定理4.1

     一个限制哈希族函数F应当具有以下的属性：
     1.F 是 单调的。
     2.具有平衡性
     3.离散性
     4.负载性

证明：
     单调性是直接的，当一个新的桶被添加时，唯一需要被移动的是离这个桶最近的关联点，将这些需要移动的节点移动到新的桶中，但是不能在旧的桶之间移动对象。离散属性和负载属性可能有很高的概率，一个点从每一个视图都是来的长度都是O（t/C).通过观察，离散型的对象上限是基于桶的上限的，毕竟没有任何一个桶可以接近任何一个视图。标准的切尔诺夫方案适合这个观点。负载均衡遵循类似的观点，我们计算的该项目的节点数量和该地区拥有一个桶相关联的节点。平衡性符和如下的事实，当有klog(C）个节点在映射到一个随机的单元，每一个节点都相对的获取对象。这里的关键在于，
分配合理的数量的节点进入到每一个桶中。这种改变时多项的。然后我们认为有很高的可能性，没有发生样的情况通过展示所有的每一个额外的桶的情况。我们推断这种长度小于O(1/|V|).以上的所有证明都可以使用log(C)的方法来独立映射完成。下面的推论都是及时的，以及在本篇论文都会一直使用。

定理4.2
公式参考@4附录。

4.3 实施
    在这一节我们将会展示如何使用哈希族函数来有效工作。特别的我们使用一个哈希函数期望的时间是O（1）。我们根据期望来选择哈希函数。我们希望删除或者添加一个桶的时间是O（logC)期中C是一个视图中的对象的上界。一个简单的解决方法是使用一个平衡二叉树来存储桶之间的对应关系。如果这里有C个桶则间隔为K（C）或者log(C),所以深度为O（log(C)).因此一次简单的哈希计算将会使用O（log(C)).则增加一个桶或者删除一个桶的时间为O(log^2(C)).因为我们需要添加或者删除klog(C)个点对于每一个桶。

   以下的一些技巧可以减少我们哈希的运行时间，达到O(1)时间复杂度。基本思想是按照log(C)的长度，去划分成等长度的段，并且为每一个段维持一个单独的搜索树。因此，我们哈希函数消耗的时间决定于间隔的时间和树搜索桶的时间。第一个部分总是O(1)的。所以，期望每一个分段时间总是O（1）第二个时间我们期望是O（1）的。
   一个说明是，随着桶的数量的增长，那么区间就会被压缩。为了处理这种情形，我们将会的间隔将会变成，1/(2^x)x根据我们的需要选择。
   首先我们选择最大的X取值可以到，1/2^x <= 1/Clog(C),当点逐渐增多，我们采用二分法分段，当逐渐分为2的次幂，我们已经达了，所有的段。这样使用这种方法我们就完成了查找树的添加和删除。另一个点是如果搜索树之间为空则他们需要被更新，当一个桶被添加，他们可能都是距离这个桶最近的搜索树。由于预测的空间隔时很小的，额外的程本是可以忽略不计的，对于一个更完整的分析，我们指的是完整的版本的文件。
   

4.4 关于一致性哈希的一些定理

	在这一节，我们将讨论一些额外的功能关于一致性哈希，占用这篇论文额外的一些东西，证明一些额外的有趣的性质。
        要深入的观察下单调性质，我们将会定义一些新的哈希函数并且展示这些单调的额外的哈希函数。
	A PI-hash 函数是一个哈希函数常见形式就是2^B * I -> B 这样的构造。如果i属于I则关联置换到所有的桶B.注意排列不需要一致或者独立。

4.3

   每一个具有单调范围的哈希函数是一个PI哈希函数，反之亦然 。
证明：
 
   对于一个限制哈希函数，函数具有传递性，数学证明暂时不译。

普遍性：
  
   一个哈希函数族中的函数是具有通用性的，如果限制每一个函数族的功能，那么每一个视图中的的哈希族函数就是创建的一个哈希族函数。这种属性是限制一个视图中哈希函数的一种方法。以上的限制情况是迫切的。如果一个视图是固定的，那么对象将会被随机的分配到视图中。这意味着在任何视图中，每一个桶期望得到的项目个数是j/|V|.只是单调性，这样的事实是分配是均匀的。我们可以决定每一个桶内对象数的预期变化。这涉及到“平滑”非正式概念。

定理4.4-4.5及其证明这里并未给出具体的翻译，主要就是证明其中一些哈希函数的正确性，散列性。

一个简单方法创建一个一致性哈希函数是随机分配分数到桶里，概率对于每一个桶都是独立的。将这些分数定以一组随机排列，因此在本节中得到了良好的性质。然而找到一个项目所属的桶，需要计算所有的分数。可能在很多个桶的时候，这样会很慢。

5 随机树的不一致表现

	在这一节中，我们需要将最后一节中的知识扩展然后使用到第三节中的问题中去。现在我们假设一种较好的情形，所有的客户端知道所有的缓存。
	我们假设每一个及其都知道1/t 的缓存。协议中没有什么区别，只是映射的是一致性哈希函数。这种变化并不会影响延时，因此，我们分析了对存储的效果影响。
	一致性哈希的基本属性是很关键的，因为这个属性协议才变的有效。专门的，暴涨的时可发生在请求的数量和存数的数量比例到达哈希函数最值的时候出现。

6.非均匀通信成本

	到目前为止我们假设所有的机器都可以安逸均等的通信。在这一节中我们扩展我们的协议，到延迟的机器和账户级别。
	
	整个请求的等待时间是由于交叉连接产生的延时总和。为了简单分析起见，在本节中，所有的客户端，都知道机器的缓存。我们扩展我们的协议到限制类的功能，
	专门的，我们假设这是一个超度量的。正式的超度量服从一个严格的三角不等式。
	
	超度量是一个互联网距离的自然模型，因为实质上是互联网拓扑结构的层次性。在这之下，举个例子，所有的机器都在一个大学，但是它距离其它的就很远，甚至在另一个大陆。
	
	在物理的互联网上建立了一个逻辑上的连通模型，一般情况下着两个点之间的延迟取决于最高级别节点之间的物理通信链路，他们必须在整个路径上被遍历。
	
	事实上，一个超度量的另一个定义是作为聚类的点。两个超度量之间的距离是完全确定的包含两个聚簇的点。
6.1 协议	
	我们修改这个协议唯一的地方就在，当一个浏览器映射到缓存树的节点后，它只使用缓存为基础尝试获取服务器所需要的页面。通过做这些，我们必须要判断我们的路径到服务器不包含不必要的缓存，使用一致性哈希函数是解决这种映射问题的重要元素。
	很明显，如果浏览器周围只有缓存并没有很多服务器，并且有许多的浏览器那就会引起拥塞。因此为了解决浏览器和缓存相距很遥远，存在超度量但是没有很多的缓存，我们限制超度量出现在协议中。这种限制是出现在很多集合中缓存的比下降的非常低的情况。
这种限制在现实情况下是说的通的，缓存可能均匀的分布在互联网上，这时很必要的，我们可以证明，大量的浏览器聚集在一个高速缓存中，可以在某些高速缓存中被迫淹没。

